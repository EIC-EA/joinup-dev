<?php

/**
 * @file
 * Contains \JoinupSeoSubContext.
 */

declare(strict_types = 1);

use Behat\Gherkin\Node\TableNode;
use Drupal\DrupalExtension\Context\DrupalSubContextBase;
use Drupal\DrupalExtension\Context\DrupalSubContextInterface;
use PHPUnit\Framework\Assert;

/**
 * Behat step definitions for testing SEO.
 */
class JoinupSeoSubContext extends DrupalSubContextBase implements DrupalSubContextInterface {

  /**
   * Asserts a meta tag value in the page.
   *
   * @param string $meta_name
   *   The meta tag name.
   * @param string $meta_value
   *   The meta tag value.
   *
   * @throws \Exception
   *   Thrown when an tag is not found or the value is not correct.
   *
   * @Given the :meta_name metatag should be set to :meta_value
   */
  public function assertMetatagInPage(string $meta_name, string $meta_value): void {
    $xpath = "//head/meta[@name=\"{$meta_name}\" and @content=\"{$meta_value}\"]";
    if (empty($this->getSession()->getPage()->find('xpath', $xpath))) {
      throw new Exception("The meta property '{$meta_name}' was either not found or the value is not set to '{$meta_value}'");
    }
  }

  /**
   * Asserts that the schema.org metatags are attached in page.
   *
   * @Given the metatag JSON should be attached in the page
   */
  public function assertJsonMetatagsInPage(): void {
    $json = $this->getMetatagsAsJson();
    Assert::assertNotEmpty($json, 'Entity metadata are found in the table.');
    // Assert that the context of the metatag is 'schema.org' to ensure that the
    // correct metatag is loaded and exists.
    Assert::assertArrayHasKey('@context', $json, '@context key not found in the metatag array.');
    Assert::assertEquals($json['@context'], 'https://schema.org', 'The @context property value is not set to the appropriate url.');
  }

  /**
   * Asserts that the schema.org metatags are attached in page.
   *
   * @Given the metatag JSON should not be attached in the page
   */
  public function assertMetatagsNotInPage(): void {
    $json = $this->getMetatagsAsJson();
    Assert::assertEmpty($json, 'Entity metadata are not attached in the page.');
  }

  /**
   * Asserts the amount of entity graphs of a certain type.
   *
   * @param int $count
   *   The number of graphs of the given type.
   * @param string $type
   *   The type of graph which is the schema class.
   *
   * @Given :count metatag graph of type :type should exist in the page
   */
  public function assertNumberOfEntityGraphsExist(int $count, string $type): void {
    $json = $this->getMetatagsAsJson();
    $found = 0;
    foreach ($json['@graph'] as $graph) {
      $graph = (array) $graph;
      if ($graph['@type'] === $type) {
        $found++;
      }
    }
    Assert::assertEquals((int) $count, $found, "{$count} graphs of type {$type} were expected. {$found} were found.");
  }

  /**
   * Asserts a list of properties in the graph identified by a property.
   *
   * @param string $property
   *   The property of which to identify the graph by.
   * @param string $value
   *   The value of the property of which to identify the graph by.
   * @param \Behat\Gherkin\Node\TableNode $table
   *   A table of properties for the given graph.
   * @param string|null $sub_property
   *   A sub property to look into.
   *
   * @throws \Exception
   *   Thrown if the graph is not found in the page or the requested sub
   *   property does not exist.
   *
   * @Given the metatag (sub)graph of the item with :property :value should have the following properties:
   * @Given the metatag (sub)graph of the item with :property :value should have the following :sub_property properties:
   */
  public function assertPropertiesOfMetatagGraph(string $property, string $value, TableNode $table, string $sub_property = NULL): void {
    $graphs = $this->getGraphsFromMetatags($property, $value, $sub_property);
    if (empty($graphs)) {
      throw new \Exception("No graphs were found that have a property '{$property}' of value '{$value}' or none of them contain a '{$sub_property}' property.");
    }

    // The url structure is very important in the SEO metatags as a wrong url
    // or an internal path could cause search engines to be missleaded. Thus,
    // the full url must be always asserted.
    $base_url = \Drupal::request()->getSchemeAndHttpHost();

    $hash = $table->getColumnsHash();
    foreach ($graphs as $graph) {
      foreach ($hash as $row) {
        if (!isset($graph[$row['property']])) {
          continue 2;
        }

        $row['value'] = str_replace('$base_url$', $base_url, $row['value']);
        if ($graph[$row['property']] !== $row['value']) {
          continue 2;
        }
      }
      // Graph was found.
      return;
    }

    throw new Exception('None of the found graphs meet the criteria.');
  }

  /**
   * Retrieves the entity metatags as a JSON array from the page.
   *
   * @return array|null
   *   The SEO metatags as an array or null if not found.
   */
  protected function getMetatagsAsJson(): ?array {
    $page = $this->getSession()->getPage();
    if ($script = $page->find('xpath', '//script[@type="application/ld+json"]')) {
      $json = $script->getText();
      return json_decode($json, TRUE);
    }

    return NULL;
  }

  /**
   * Searches the metatag array for the first graph that matches the criteria.
   *
   * @param string $property
   *   The property of which to identify the graph by.
   * @param string $value
   *   The value of the property of which to identify the graph by.
   * @param string|null $sub_graph
   *   (optional) Fetch a subgraph of the graphs instead of the graph itself.
   *
   * @return array|null
   *   The first graph that matches the criteria as an array or null if no match
   *   is found.
   */
  protected function getGraphsFromMetatags(string $property, string $value, string $sub_graph = NULL): ?array {
    $json = $this->getMetatagsAsJson();
    $sub_graphs = $this->getSubGraphsFromGraph($json, $property, $value);
    if (!empty($sub_graph)) {
      $sub_graphs = array_map(function (array $graph) use ($sub_graph) {
        return array_key_exists($sub_graph, $graph) ? $graph[$sub_graph] : NULL;
      }, $sub_graphs);
    }
    return array_filter($sub_graphs);
  }

  /**
   * Retrieves a list of subgraphs from a graph.
   *
   * Used to search for a property within the graph that contains a subproperty.
   * For example, a graph contains a location property which in turn contains a
   * sub property that has a latitude and a longitude. This method can search
   * either simply by the identifier or if the identifier contains a property or
   * if the property contained by an identifier matches a value.
   *
   * @param array $graph
   *   The parent graph.
   * @param string $identifier
   *   The property name to identify the graph with.
   * @param string|null $identifier_value
   *   (optional) The identifier value. Should not be used along with $property
   *   filter as the $identifier_value requires $identifier to have a string
   *   value, while $property requires it to have an array as a value.
   * @param bool $reset
   *   Reset the list of graphs. This method might run multiple times over many
   *   scenarios so the static variable $graphs_found might leak results in
   *   other cases. Initial value must always be TRUE while every subsequent
   *   call from within the method will be FALSE.
   *
   * @return array
   *   An array of subgraphs that match the above criteria.
   */
  protected function getSubGraphsFromGraph(array $graph, string $identifier, string $identifier_value = NULL, bool $reset = TRUE): array {
    static $graphs_found = [];
    if ($reset) {
      $graphs_found = [];
    }
    foreach ($graph as $sub_graph_or_value) {
      if (is_array($sub_graph_or_value)) {
        if (array_key_exists($identifier, $sub_graph_or_value)) {
          if (is_array($sub_graph_or_value[$identifier])) {
            if (empty($property)) {
              // No filter is required on the subgraph so the whole graph is
              // valid.
              $graphs_found[] = $sub_graph_or_value;
            }
          }
          // A non strict comparison is used because in behat, parameter values
          // are usually strings. Values can still be integers though.
          elseif (!empty($identifier_value) && $sub_graph_or_value[$identifier] == $identifier_value) {
            $graphs_found[] = $sub_graph_or_value;
          }
        }
        // In any case, the subgraph is an array so search deeper for valid
        // instances of subgraphs.
        $this->getSubGraphsFromGraph($sub_graph_or_value, $identifier, $identifier_value, FALSE);
      }
    }
    return $graphs_found;
  }

}
