<?php

/**
 * @file
 * Contains the main functionality of Joinup Group module.
 */

declare(strict_types=1);

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Cache\Cache;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\file\Entity\File;
use Drupal\joinup_group\JoinupGroupHelper;
use Drupal\menu_link_content\Entity\MenuLinkContent;
use Drupal\og\Og;
use Drupal\og\OgGroupAudienceHelperInterface;
use Drupal\og_menu\Entity\OgMenuInstance;
use Drupal\rdf_entity\RdfInterface;

/**
 * Implements hook_preprocess_page().
 *
 * Adds the current og group context as attribute on the page wrapper.
 */
function joinup_group_preprocess_page(&$variables) {
  /** @var \Drupal\Core\Plugin\Context\ContextInterface[] $context */
  $context = \Drupal::service('og.context')->getRuntimeContexts(['og']);

  if (!empty($context['og'])) {
    $group = $context['og']->getContextValue();

    if ($group && $group->getEntityTypeId() === 'rdf_entity') {
      $variables['attributes']['data-drupal-group-context'] = $group->id();
    }
  }
}

/**
 * Implements hook_entity_type_alter().
 */
function joinup_group_entity_type_alter(array &$entity_types) {
  // Swap the default user cancel form implementation with a custom one that
  // prevents deleting users when they are the sole owner of a group.
  $entity_types['user']->setFormClass('cancel', 'Drupal\joinup_group\Form\UserCancelForm');
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 *
 * Adds a submit handler that will show a message to the user after proposing a
 * collection or solution.
 */
function joinup_group_form_rdf_entity_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  /** @var \Drupal\rdf_entity\Form\RdfForm $form_object */
  $form_object = $form_state->getFormObject();
  /** @var \Drupal\rdf_entity\RdfInterface $rdf */
  $rdf = $form_object->getEntity();

  // Add submit callback when the current bundle is in the list and when we are
  // in an affected operation type.
  $operation_types = ['add', 'default', 'propose'];
  if (JoinupGroupHelper::isGroup($rdf) && in_array($form_object->getOperation(), $operation_types)) {
    $form['actions']['submit']['#submit'][] = 'joinup_core_propose_message_submit';
  }
}

/**
 * Submit callback for the propose form of a collection or solution.
 *
 * Informs the user that a newly proposed collection or solution needs approval.
 */
function joinup_group_propose_message_submit(&$form, FormStateInterface $form_state) {
  $form_object = $form_state->getFormObject();
  $fields = ['collection' => 'field_ar_state', 'solution' => 'field_is_state'];
  $entity = $form_object->getEntity();
  $state = $entity->get($fields[$entity->bundle()])->value;

  if ($state === 'proposed') {
    \Drupal::messenger()->addStatus(t('Thank you for proposing a @entity_label. Your request is currently pending approval by the site administrator.', ['@entity_label' => $entity->get('rid')->entity->getSingularLabel()]));
  }
}

/**
 * Implements hook_entity_graph_access().
 *
 * The same procedure as the global access check is followed here. The purpose
 * is to override the results of the global access check if the user has the
 * appropriate OG permissions.
 *
 * @todo: hook api definition is needed.
 */
function joinup_group_entity_graph_access(EntityInterface $entity, string $operation, AccountInterface $account, string $graph_name): AccessResult {
  if (!$entity || !JoinupGroupHelper::isGroup($entity) || $operation != 'view' || $graph_name == 'default') {
    return AccessResult::neutral();
  }

  $membership = Og::getMembership($entity, $account);
  if (empty($membership)) {
    return AccessResult::neutral();
  }

  // Following the same logic as the global access check.
  $map = ['view' => 'view all graphs'];
  $entity_type_id = $entity->getEntityTypeId();
  $type_map = ['view' => "view $entity_type_id $graph_name graph"];

  // If the operation is not supported, do not allow access.
  if (!isset($map[$operation]) || !isset($type_map[$operation])) {
    return AccessResult::forbidden();
  }

  $has_permission = $membership->hasPermission($map[$operation]) || $membership->hasPermission($type_map[$operation]);
  return $has_permission ? AccessResult::allowed() : AccessResult::neutral();
}

/**
 * Implements hook_ENTITY_TYPE_insert() for RDF entities.
 */
function joinup_group_rdf_entity_insert(RdfInterface $entity): void {
  // When a collection or solution is created, create a new navigation menu and
  // associate it with the new collection or solution. This menu can be used to
  // link to custom pages, member overviews, an about page etc.
  if (Og::isGroup($entity->getEntityTypeId(), $entity->bundle()) && in_array($entity->bundle(), ['collection', 'solution'])) {
    $values = [
      'type' => 'navigation',
      OgGroupAudienceHelperInterface::DEFAULT_FIELD => $entity->id(),
    ];
    $og_menu_instance = OgMenuInstance::create($values);
    $og_menu_instance->save();

    // Automatically add a link to the overview and about pages of the
    // collection entity.
    $menu_name = 'ogmenu-' . $og_menu_instance->id();
    $link = MenuLinkContent::create([
      'title' => t('Overview'),
      'menu_name' => $menu_name,
      'link' => ['uri' => $entity->toUrl()->toUriString()],
      'weight' => -10,
    ]);
    $link->save();

    $link = MenuLinkContent::create([
      'title' => t('Members'),
      'menu_name' => $menu_name,
      'link' => ['uri' => $entity->toUrl('member-overview')->toUriString()],
      'weight' => -9,
    ]);
    $link->save();

    $link = MenuLinkContent::create([
      'title' => t('About'),
      'menu_name' => $menu_name,
      'link' => ['uri' => $entity->toUrl('about-page')->toUriString()],
      'weight' => -8,
    ]);
    $link->save();
  }

  // Invalidate all list caches tagged with the affected bundle so the that
  // they will be regenerated.
  Cache::invalidateTags(["rdf_entity_list:{$entity->bundle()}"]);
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 *
 * During the hook_update, the entity is already saved. This renders impossible
 * to determine whether there was a published version before. Yet, the email
 * cannot be sent during the presave because the save action has not completed
 * yet and anything could go wrong. Thus, a property is set to define whether
 * the entity had a published version previously.
 *
 * Also, provide default images for collections and solutions in case they are
 * empty.
 */
function joinup_group_rdf_entity_presave(EntityInterface $entity) {
  if (!JoinupGroupHelper::isGroup($entity)) {
    return;
  }

  if ($entity->isNew()) {
    $entity->hasPublished = FALSE;
  }
  else {
    $entity->hasPublished = $entity->hasGraph('default');
  }

  $field_data = [
    'logo' => ['field_ar_logo', 'field_is_logo'],
    'banner' => ['field_ar_banner', 'field_is_banner'],
  ];

  $fixtures_path = drupal_get_path('module', 'joinup_core') . '/fixtures/images/';
  foreach ($field_data as $field_type => $fields) {
    foreach ($fields as $field) {
      if ($entity->hasField($field) && empty($entity->get($field)->getValue())) {
        // Get files without the . and .. directories.
        $files = array_slice(scandir($fixtures_path . $field_type), 2);
        $random = array_rand($files);
        $file_path = \Drupal::service('file_system')->realpath($fixtures_path . $field_type . '/' . $files[$random]);
        $file_path = file_unmanaged_copy($file_path, 'public://');
        $file = File::create(['uri' => $file_path]);
        $file->save();
        $entity->set($field, $file->id());
      }
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_update().
 *
 * Re-index all group content when a group is saved with a changed status.
 *
 * The hasPublished flag ensures that this will occur only when an entity is
 * published for the first time.
 *
 * @see \joinup_group_rdf_entity_presave()
 */
function joinup_group_rdf_entity_update(EntityInterface $entity) {
  if (!JoinupGroupHelper::isGroup($entity)) {
    return;
  }

  if ($entity->isPublished() && isset($entity->hasPublished) && $entity->hasPublished === FALSE) {
    /** @var \Drupal\og\MembershipManagerInterface $membership_manager */
    $membership_manager = \Drupal::service('og.membership_manager');
    $content_ids = $membership_manager->getGroupContentIds($entity, ['node']);
    $entities = \Drupal::entityTypeManager()->getStorage('node')->loadMultiple($content_ids['node']);
    foreach ($entities as $entity_item) {
      $entity_item->original = $entity_item;
      search_api_entity_update($entity_item);
    }
  }
}
